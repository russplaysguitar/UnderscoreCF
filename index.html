<!DOCTYPE html>
<html>
<head>
	<title>Underscore.cfc</title>
	<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="chrome=1" />
	<meta name="viewport" content="width=device-width" />
	<link rel="stylesheet" type="text/css" href="index_files/style.css" />
</head>
<body>
	<div id="sidebar" class="interface">
		<a class="toc_title" href="#">
		    Underscore.cfc <span class="version">(2.3)</span>
	    </a>
	    <a class="toc_title" href="#">
	    	Introduction
	    </a>
    	
		    <a class="toc_title" href="#Collections">
			    Collections
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href='#each'>each</a></li><li>- <a href='#map'>map</a></li><li>- <a href='#reduce'>reduce</a></li><li>- <a href='#reduceRight'>reduceRight</a></li><li>- <a href='#find'>find</a></li><li>- <a href='#filter'>filter</a></li><li>- <a href='#where'>where</a></li><li>- <a href='#reject'>reject</a></li><li>- <a href='#all'>all</a></li><li>- <a href='#any'>any</a></li><li>- <a href='#include'>include</a></li><li>- <a href='#invoke'>invoke</a></li><li>- <a href='#pluck'>pluck</a></li><li>- <a href='#max'>max</a></li><li>- <a href='#min'>min</a></li><li>- <a href='#sortBy'>sortBy</a></li><li>- <a href='#groupBy'>groupBy</a></li><li>- <a href='#countBy'>countBy</a></li><li>- <a href='#sortedIndex'>sortedIndex</a></li><li>- <a href='#shuffle'>shuffle</a></li><li>- <a href='#toArray'>toArray</a></li><li>- <a href='#size'>size</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Arrays">
			    Arrays
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href='#first'>first</a></li><li>- <a href='#initial'>initial</a></li><li>- <a href='#last'>last</a></li><li>- <a href='#rest'>rest</a></li><li>- <a href='#compact'>compact</a></li><li>- <a href='#flatten'>flatten</a></li><li>- <a href='#without'>without</a></li><li>- <a href='#union'>union</a></li><li>- <a href='#intersection'>intersection</a></li><li>- <a href='#difference'>difference</a></li><li>- <a href='#uniq'>uniq</a></li><li>- <a href='#zip'>zip</a></li><li>- <a href='#object'>object</a></li><li>- <a href='#indexOf'>indexOf</a></li><li>- <a href='#lastIndexOf'>lastIndexOf</a></li><li>- <a href='#range'>range</a></li><li>- <a href='#concat'>concat</a></li><li>- <a href='#reverse'>reverse</a></li><li>- <a href='#takeWhile'>takeWhile</a></li><li>- <a href='#splice'>splice</a></li><li>- <a href='#push'>push</a></li><li>- <a href='#unshift'>unshift</a></li><li>- <a href='#join'>join</a></li><li>- <a href='#slice'>slice</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Functions">
			    Functions
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href='#bind'>bind</a></li><li>- <a href='#bindAll'>bindAll</a></li><li>- <a href='#memoize'>memoize</a></li><li>- <a href='#delay'>delay</a></li><li>- <a href='#once'>once</a></li><li>- <a href='#debounce'>debounce</a></li><li>- <a href='#after'>after</a></li><li>- <a href='#wrap'>wrap</a></li><li>- <a href='#compose'>compose</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Objects">
			    Objects
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href='#keys'>keys</a></li><li>- <a href='#values'>values</a></li><li>- <a href='#pairs'>pairs</a></li><li>- <a href='#invert'>invert</a></li><li>- <a href='#functions'>functions</a></li><li>- <a href='#extend'>extend</a></li><li>- <a href='#pick'>pick</a></li><li>- <a href='#omit'>omit</a></li><li>- <a href='#defaults'>defaults</a></li><li>- <a href='#clone'>clone</a></li><li>- <a href='#has'>has</a></li><li>- <a href='#isEqual'>isEqual</a></li><li>- <a href='#isEmpty'>isEmpty</a></li><li>- <a href='#isArray'>isArray</a></li><li>- <a href='#isObject'>isObject</a></li><li>- <a href='#isFunction'>isFunction</a></li><li>- <a href='#isString'>isString</a></li><li>- <a href='#isNumber'>isNumber</a></li><li>- <a href='#isBoolean'>isBoolean</a></li><li>- <a href='#isDate'>isDate</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Utilities">
			    Utilities
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href='#times'>times</a></li><li>- <a href='#random'>random</a></li><li>- <a href='#mixin'>mixin</a></li><li>- <a href='#uniqueId'>uniqueId</a></li><li>- <a href='#escape'>escape</a></li><li>- <a href='#result'>result</a></li>			    	
		    </ul>
    	
	    <a class="toc_title" href="#changelog">
	    	Change Log
	    </a>    	
	</div>
	<div class="container">
		<h1>Underscore.cfc</h1>
		<p id="Introduction">
			Underscore.cfc is a port of <a href="http://underscorejs.org">Underscore.js</a> for Coldfusion. It is a utility-belt library that provides a lot of the functional programming support that you would expect in Prototype.js (or Ruby). <br /><br />Underscore.cfc provides dozens of functions that support both the usual functional suspects: map, select, invoke - as well as more specialized helpers: function binding, sorting, deep equality testing, and so on. It delegates to built-in functions where applicable.<br /><br />Underscore.cfc is compatible with Adobe Coldfusion 10 and Railo 4.<br /><br />The project is <a href="http://github.com/russplaysguitar/underscorecf">hosted on GitHub</a>. Contributions are welcome.<br />
		</p>		
		<h2>Download</h2>
		<div><a href="https://github.com/russplaysguitar/UnderscoreCF/archive/v2.3.zip">Version 2.3</a> - <i>~40kb, Includes all development files</i></div>
		<h2 id="Collections">Collection Functions (Arrays, Structs, Queries, or Objects)</h2>
		

<p id='each'><b class='header'>each</b> <code>_.each(collection, iterator, [context]) : void</code><br />Iterates over a collection of elements, yielding each in turn to an iterator function. The iterator is bound to the context object (component or struct), if one is passed. Each invocation of iterator is called with three arguments: (element, index, collection, this). If collection is an object/struct, iterator's arguments will be (value, key, collection, this).<br /><pre>_.each([1, 2, 3], function(num){ writeDump(num); }); <br />=> dumps each number in turn... <br />_.each({one : 1, two : 2, three : 3}, function(num, key){ writeDump(num); });<br />=> dumps each number in turn...</pre></p>

<p id='map'><b class='header'>map</b> <code>_.map(collection, iterator, [context]) : array</code><br />Produces a new array of values by mapping each value in collection through a transformation function (iterator). If collection is an object/struct, iterator's arguments will be (value, key, collection, this).<br /><pre>_.map([1, 2, 3], function(num){ return num * 3; }); <br />=> [3, 6, 9] <br />_.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3; });<br />=> [3, 6, 9]</pre></p>

<p id='reduce'><b class='header'>reduce</b> <code>_.reduce(collection, iterator, memo, [context]) : any</code><br />Also known as inject and foldl, reduce boils down a collection of values into a single value. Memo is the initial state of the reduction, and each successive step of it should be returned by iterator.<br /><pre>sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);<br />=> 6</pre></p>

<p id='reduceRight'><b class='header'>reduceRight</b> <code>_.reduceRight(collection, [iterator], memo, [context])</code><br />The right-associative version of reduce.<br /><pre>list = [[0, 1], [2, 3], [4, 5]];<br />flat = _.reduceRight(list, function(a, b) { return _.concat(a, b); }, []);<br />=> [4, 5, 2, 3, 0, 1]</pre></p>

<p id='find'><b class='header'>find</b> <code>_.find(collection, iterator, [context]) : any</code><br />Looks through each value in the collection, returning the first one that passes a truth test (iterator). The function returns as soon as it finds an acceptable element, and doesn't traverse the entire collection.<br /><pre>even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br />=> 2</pre></p>

<p id='filter'><b class='header'>filter</b> <code>_.filter(collection, iterator, [context]) : array</code><br />Looks through each value in the collection, returning an array of all the values that pass a truth test (iterator).<br /><pre>evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br />=> [2, 4, 6]</pre></p>

<p id='where'><b class='header'>where</b> <code>_.where(list, properties) : array</code><br />Looks through each value in the list, returning an array of all the values that contain all of the key-value pairs listed in properties.<br /><pre>_.where(listOfPlays, {author: "Shakespeare", year: 1611});<br />=> [{title: "Cymbeline", author: "Shakespeare", year: 1611},<br />    {title: "The Tempest", author: "Shakespeare", year: 1611}]</pre></p>

<p id='reject'><b class='header'>reject</b> <code>_.reject(collection, iterator, [context]) : array</code><br />Returns the values in collection without the elements that the truth test (iterator) passes. The opposite of filter.<br /><pre>odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br />=> [1, 3, 5]</pre></p>

<p id='all'><b class='header'>all</b> <code>_.all(collection, iterator, [context]) : boolean</code><br />Returns true if all of the values in the collection pass the iterator truth test.<br /><pre>_.all([true, 1, 'no'], _.identity);<br />=> false</pre></p>

<p id='any'><b class='header'>any</b> <code>_.any(collection, [iterator], [context]) : boolean</code><br />Returns true if any of the values in the collection pass the iterator truth test. Short-circuits and stops traversing the collection if a true element is found.<br /><pre>_.any([0, 'yes', false]);<br />=> true</pre></p>

<p id='include'><b class='header'>include</b> <code>_.include(collection, value) : boolean</code><br />Returns true if the value is present in the collection.<br /><pre>_.include([1, 2, 3], 3);<br />=> true</pre></p>

<p id='invoke'><b class='header'>invoke</b> <code>_.invoke(collection, methodName, [arguments]) : array</code><br />Calls the method named by methodName on each value in the collection. The arguments struct passed to invoke will be forwarded on to the method invocation.<br /><pre>_.invoke([{fun: function(){ return 1; }}], 'fun');<br />=> [1]</pre></p>

<p id='pluck'><b class='header'>pluck</b> <code>_.pluck(collection, propertyName) : array</code><br />A convenient version of what is perhaps the most common use-case for map: extracting a collection of property values.<br /><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br />_.pluck(stooges, 'name');<br />=> ["moe", "larry", "curly"]</pre></p>

<p id='max'><b class='header'>max</b> <code>_.max(collection, [iterator], [context]) : any</code><br />Returns the maximum value in collection. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br /><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br />_.max(stooges, function(stooge){ return stooge.age; });<br />=> {name : 'curly', age : 60};</pre></p>

<p id='min'><b class='header'>min</b> <code>_.min(collection, [iterator], [context]) : any</code><br />Returns the minimum value in collection. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br /><pre>numbers = [10, 5, 100, 2, 1000];<br />_.min(numbers);<br />=> 2</pre></p>

<p id='sortBy'><b class='header'>sortBy</b> <code>_.sortBy(collection, [iterator], [context]) : array</code><br />Returns a sorted copy of collection, ranked in ascending order by the results of running each value through iterator. Iterator may also be the string name of the object key to sort by. Delegates to arraySort().<br /><pre>_.sortBy([6, 2, 4, 3, 5, 1], function(num){ return num; });<br />=> [1, 2, 3, 4, 5, 6]</pre></p>

<p id='groupBy'><b class='header'>groupBy</b> <code>_.groupBy(collection, iterator) : struct</code><br />Splits a collection into sets, grouped by the result of running each value through iterator. If iterator is a string instead of a function, groups by the property named by iterator on each of the values.<br /><pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return fix(num); });<br />=> {1: [1.3], 2: [2.1, 2.4]}<br /><br />_.groupBy(['one', 'two', 'three'], function(num) { return len(num); });<br />=> {3: ["one", "two"], 5: ["three"]}</pre></p>

<p id='countBy'><b class='header'>countBy</b> <code>_.countBy(collection, iterator) : struct</code><br />Sorts a collection into groups and returns a count for the number of objects in each group. Similar to groupBy, but instead of returning a list of values, returns a count for the number of values in that group.<br /><pre>_.countBy([1, 2, 3, 4, 5], function(num) { return num % 2 == 0 ? 'even' : 'odd'; });<br />=> {odd: 3, even: 2}</pre></p>

<p id='sortedIndex'><b class='header'>sortedIndex</b> <code>_.sortedIndex(collection, value, [iterator]) : numeric</code><br />Uses a binary search to determine the index at which the value should be inserted into the collection in order to maintain the collection's sorted order. If an iterator is passed, it will be used to compute the sort ranking of each value.<br /><pre>_.sortedIndex([10, 20, 30, 40, 50], 35);<br />=> 4</pre></p>

<p id='shuffle'><b class='header'>shuffle</b> <code>_.shuffle(array) : array</code><br />Returns a shuffled copy of the array, using a version of the Fisher-Yates shuffle.<br /><pre>_.shuffle([1, 2, 3, 4, 5, 6]);<br />=> [4, 1, 6, 3, 5, 2]</pre></p>

<p id='toArray'><b class='header'>toArray</b> <code>_.toArray(collection) : array</code><br />Converts the collection (object, struct, query, or cf-list), into an array. Useful for transmuting the arguments object.<br /><pre>_.toArray({a:10,b:20});<br />=> [10, 20]</pre></p>

<p id='size'><b class='header'>size</b> <code>_.size(collection) : numeric</code><br />Return the number of values in the collection.<br /><pre>_.size({one : 1, two : 2, three : 3});<br />=> 3</pre></p>
		<h2 id="Arrays">Array Functions</h2>
		

<p id='first'><b class='header'>first</b> <code>_.first(array, [n]) : any</code><br />Returns the first element of an array. Passing n will return the first n elements of the array.<br /><pre>_.first([5, 4, 3, 2, 1]);<br />=> 5</pre></p>

<p id='initial'><b class='header'>initial</b> <code>_.initial(array, [n]) : array</code><br />Returns everything but the last entry of the array. Especially useful on the arguments object. Pass n to exclude the last n elements from the result. Note: CF arrays start at an index of 1<br /><pre>_.initial([5, 4, 3, 2, 1]);<br />=> [5, 4, 3, 2]</pre></p>

<p id='last'><b class='header'>last</b> <code>_.last(array, [n]) : any</code><br />Returns the last element of an array. Passing n will return the last n elements of the array.<br /><pre>_.last([5, 4, 3, 2, 1]);<br />=> 1</pre></p>

<p id='rest'><b class='header'>rest</b> <code>_.rest(array, [index]) : array</code><br />Returns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.<br /><pre>_.rest([5, 4, 3, 2, 1]);<br />=> [4, 3, 2, 1]</pre></p>

<p id='compact'><b class='header'>compact</b> <code>_.compact(array) : array</code><br />Returns a copy of the array with all falsy values removed. In Coldfusion, false, 0, and "" are all falsy.<br /><pre>_.compact([0, 1, false, 2, '', 3]);<br />=> [1, 2, 3]</pre></p>

<p id='flatten'><b class='header'>flatten</b> <code>_.flatten(array, [shallow]) : array</code><br />Flattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.<br /><pre>_.flatten([1, [2], [3, [[4]]]]);<br />=> [1, 2, 3, 4];<br /><br />_.flatten([1, [2], [3, [[4]]]], true);<br />=> [1, 2, 3, [[4]]];</pre></p>

<p id='without'><b class='header'>without</b> <code>_.without(array, [values]) : array</code><br />Returns a copy of the array with all instances of the values removed.<br /><pre>_.without([1, 2, 1, 0, 3, 1, 4], [0, 1]);<br />=> [2, 3, 4]</pre></p>

<p id='union'><b class='header'>union</b> <code>_.union(*arrays) : array</code><br />Computes the union of the passed-in arrays: the collection of unique items, in order, that are present in one or more of the arrays.<br /><pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br />=> [1, 2, 3, 101, 10]</pre></p>

<p id='intersection'><b class='header'>intersection</b> <code>_.intersection(*arrays) : array</code><br />Computes the collection of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.<br /><pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br />=> [1, 2]</pre></p>

<p id='difference'><b class='header'>difference</b> <code>_.difference(array, others) : array</code><br />Similar to without, but returns the values from array that are not present in the other arrays.<br /><pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);<br />=> [1, 3, 4]</pre></p>

<p id='uniq'><b class='header'>uniq</b> <code>_.uniq(array, [isSorted], [iterator]) : array</code><br />Produces a duplicate-free version of the array. If you know in advance that the array is sorted, passing true for isSorted will run a much faster algorithm. If you want to compute unique items based on a transformation, pass an iterator function.<br /><pre>_.uniq([1, 2, 1, 3, 1, 4]);<br />=> [1, 2, 3, 4]</pre></p>

<p id='zip'><b class='header'>zip</b> <code>_.zip(*arrays) : array</code><br />Merges together the values of each of the arrays with the values at the corresponding position. Useful when you have separate data sources that are coordinated through matching array indexes. If you're working with a matrix of nested arrays, zip.apply can transpose the matrix in a similar fashion.<br /><pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);<br />=> [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]</pre></p>

<p id='object'><b class='header'>object</b> <code>_.object(array, [values])</code><br />Converts an array into a struct. Pass either a single array of [key, value] pairs, or an array of keys, and an array of values.<br /></p>

<p id='indexOf'><b class='header'>indexOf</b> <code>_.indexOf(array, value, [isSorted/fromIndex]) : numeric</code><br />Returns the index at which value can be found in the array, or 0 if value is not present in the array. Uses the native ArrayFind() function. If you're working with a large array, and you know that the array is already sorted, pass true for isSorted to use a faster binary search.<br /><pre>_.indexOf([1, 2, 3], 2);<br />=> 2</pre></p>

<p id='lastIndexOf'><b class='header'>lastIndexOf</b> <code>_.lastIndexOf(array, value) : numeric</code><br />Returns the index of the last occurrence of value in the array, or 0 if value is not present.<br /><pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);<br />=> 5</pre></p>

<p id='range'><b class='header'>range</b> <code>_.range([start], stop, [step]) : array</code><br />A function to create flexibly-numbered arrays of integers, handy for each and map loops. start, if omitted, defaults to 0; step defaults to 1. Returns an array of integers from start to stop, incremented (or decremented) by step, exclusive.<br /><pre>_.range(10);<br />=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br />_.range(1, 11);<br />=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />_.range(0, 30, 5);<br />=> [0, 5, 10, 15, 20, 25]<br />_.range(0, -10, -1);<br />=> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br />_.range(0);<br />=> []</pre></p>

<p id='concat'><b class='header'>concat</b> <code>_.concat(array1, array2) : array</code><br />Concatenates two arrays together an returns the result. Delegates to ArrayAppend().<br /><pre>_.concat([1, 2, 3],[4, 5, 6]);<br />=> [1, 2, 3, 4, 5, 6];</pre></p>

<p id='reverse'><b class='header'>reverse</b> <code>_.reverse(array) : array</code><br />Returns a copy of the array in reverse order.<br /><pre>_.reverse([1, 2, 3]);<br />=> [3, 2, 1]</pre></p>

<p id='takeWhile'><b class='header'>takeWhile</b> <code>_.takeWhile(array) : array</code><br />Appends values to a new array as long as the iterator is true.<br /><pre>_.takeWhile([1, 2, 3, 4, 1, 2], function(val) { return val < 3; });<br />=> [1, 2]</pre></p>

<p id='splice'><b class='header'>splice</b> <code>_.splice(array, index, howMany, [*items]) : array</code><br />Returns a copy of the array with howMany elements removed. Optionally inserts items at the index. Note: differs from Javascript splice() in that it does not return the removed elements.<br /><pre>_.splice([10, 90, 30], 2, 2);<br /> => [10]<br />_.splice([10, 90, 30], 2, 1, 20);<br /> => [10, 20, 30]</pre></p>

<p id='push'><b class='header'>push</b> <code>_.push(array, *values) : array</code><br />Returns a new array with values appended to the end of it. Does not modify the original array.<br /><pre>_.push([1, 2], 3, 4);<br />=> [1, 2, 3, 4]</pre></p>

<p id='unshift'><b class='header'>unshift</b> <code>_.unshift(array, *values) : array</code><br />Returns a new array with values prepended to the array. Does not modify the original array.<br /><pre>_.unshift(["end"], "start", "middle");<br />=> ["start", "middle", "end"]</pre></p>

<p id='join'><b class='header'>join</b> <code>_.join(array, [separator]) : string</code><br />Returns a string with all array elements joined together. Default separator is a single space.<br /><pre>_.join([1, 2], " and ");<br />=> "1 and 2</pre></p>

<p id='slice'><b class='header'>slice</b> <code>_.slice(array, [from], [to]) : array</code><br />Returns a subsection of the array. Negative values for to and from offset from the end of the array.<br /><pre>_.slice([1, 2, 3, 4]);<br/>=> [2, 3, 4]<br/><br/>_.slice([1, 2, 3, 4], 3);<br/>=> [3, 4]<br/><br/>_.slice([1, 2, 3, 4], 2, -1);<br/>=> [2, 3]<br/><br/>_.slice([1, 2, 3, 4], -3, -1);<br/>=> [2, 3]</pre></p>
		<h2 id="Functions">Function (uh, ahem) Functions</h2>
		

<p id='bind'><b class='header'>bind</b> <code>_.bind(function, object, [*arguments]) : function</code><br />Bind a function to a structure, meaning that whenever the function is called, the value of "this" will be the structure. Optionally, bind arguments to the function to pre-fill them, also known as partial application.<br /><pre>func = function(args, this){ return args.greeting & ': ' & this.name; };<br />func = _.bind(func, {name : 'moe'}, {greeting: 'hi'});<br />func();<br />=> 'hi: moe'</pre></p>

<p id='bindAll'><b class='header'>bindAll</b> <code>_.bindAll(object, [*methodNames]) : any</code><br />Bind all of an object's methods to that object. Useful for ensuring that all callbacks defined on an object belong to it.<br /><pre>greeter = {hello: 'Hello, ', greet: function(this){ return this.hello & 'World!'; }};<br />_.bindAll(greeter);<br />greeter.greet();<br />=> 'Hello, World!'</pre></p>

<p id='memoize'><b class='header'>memoize</b> <code>_.memoize(function, [hashFunction]) : function</code><br />Memoizes a given function by caching the computed result. Useful for speeding up slow-running computations. If passed an optional hashFunction, it will be used to compute the hash key for storing the result, based on the arguments to the original function. The default hashFunction just uses the first argument to the memoized function as the key.<br /><pre>fibonacci = _.memoize(function(n) {  return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); });</pre></p>

<p id='delay'><b class='header'>delay</b> <code>_.delay(function, wait, arguments) : any</code><br />Delays a function for the given number of milliseconds, and then calls it with the arguments supplied in the args struct.<br /><pre>_.delay(function (msg) {return msg;}, 1000, {msg = "hi"});<br />=> "hi" // appears after one second</pre></p>

<p id='once'><b class='header'>once</b> <code>_.once(function) : function</code><br />Returns a function that will be executed at most one time, no matter how often you call it. Useful for lazy initialization.<br /><pre>i = 0;<br />once = _.once(function () { i = i+1; return i; });<br />once();<br />=> 1<br />once();<br />=> 1</pre></p>

<p id='debounce'><b class='header'>debounce</b> <code>_.debounce(function, wait, immediate) : function</code><br />Returns a function that, as long as it continues to be invoked, will not be triggered. The function will be called after it stops being called for N milliseconds. If immediate is passed, trigger the function on the leading edge, instead of the trailing. (Immediate requires a Wait cooldown period beteween calls.)<br /><pre>keepCalm = _.debounce(function(){}, 300, true);<br/>for (var i = 0; i<10; i++){ keepCalm(); }<br/>=>//function argument is called only once</pre></p>

<p id='after'><b class='header'>after</b> <code>_.after(count, function) : any</code><br />Returns a function that will only be executed after being called N times. When count <= 0, the result of calling the function immediately is returned.<br /><pre>func = function () { writeOutput("hi"); };<br />callFuncAfterTwo = _.after(2, func);<br />callFuncAfterTwo();<br />=> // nothing<br />callFuncAfterTwo();<br />=> 'hi'</pre></p>

<p id='wrap'><b class='header'>wrap</b> <code>_.wrap(function, wrapper) : function</code><br />Returns the first function passed as an argument to the second, allowing you to adjust arguments, run code before and after, and conditionally execute the original function.<br /><pre>hello = function(name) { return "hello: " & name; };<br />hello = _.wrap(hello, function(func) {<br />return "before, " & func("moe") & ", after";<br />});<br />hello();<br />=> 'before, hello: moe, after'</pre></p>

<p id='compose'><b class='header'>compose</b> <code>_.compose(*functions) : function</code><br />Returns a function that is the composition of a list of functions, each function consumes the return value of the function that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).<br /><pre>greet	= function(name){ return "hi: " & name; };<br />exclaim  = function(statement){ return statement & "!"; };<br />welcome = _.compose(exclaim, greet);<br />welcome('moe');<br />=> 'hi: moe!';</pre></p>
		<h2 id="Objects">Object/Struct Functions</h2>
		

<p id='keys'><b class='header'>keys</b> <code>_.keys(object) : array</code><br />Retrieve all the names of the object's properties.<br /><pre>_.keys({one : 1, two : 2, three : 3});<br />=> ["one", "two", "three"]</pre></p>

<p id='values'><b class='header'>values</b> <code>_.values(object) : array</code><br />Returns true if any of the values in the object pass the iterator truth test. Short-circuits and stops traversing the object if a true element is found.<br /><pre>_.values({one : 1, two : 2, three : 3});<br />=> [1, 2, 3]</pre></p>

<p id='pairs'><b class='header'>pairs</b> <code>_.pairs(object) : array</code><br />Convert an object into a list of [key, value] pairs. Notes: Resulting item order is not guaranteed. Key capitalization will depend on your CF engine.<br /><pre>_.pairs({ONE: 1, TWO: 2, THREE: 3});<br />=> [["ONE", 1], ["TWO", 2], ["THREE", 3]]</pre></p>

<p id='invert'><b class='header'>invert</b> <code>_.invert(object) : object</code><br />Returns a copy of the object where the keys have become the values and the values the keys. For this to work, all of your object's values should be unique and string serializable. Note: Capitalization will depend on your CF engine.<br /><pre>_.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});<br />=> {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};</pre></p>

<p id='functions'><b class='header'>functions</b> <code>_.functions(object) : array</code><br />Returns a sorted array of the names of every method in an object -- that is to say, the name of every function property of the object.<br /><pre>_.functions(_);<br />=> ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...</pre></p>

<p id='extend'><b class='header'>extend</b> <code>_.extend(destination, *sources) : any</code><br />Copy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.<br /><pre>_.extend({name : 'moe'}, {age : 50});<br />=> {name : 'moe', age : 50}</pre></p>

<p id='pick'><b class='header'>pick</b> <code>_.pick(object, *keys) : struct</code><br />Return a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys).<br /><pre>_.pick({name : 'moe', age: 50, userid : 'moe1'}, 'name', 'age');<br />=> {name : 'moe', age : 50}</pre></p>

<p id='omit'><b class='header'>omit</b> <code>_.omit(object, *keys) : struct</code><br />Return a copy of the object, filtered to omit the blacklisted keys (or array of keys).<br /><pre>_.omit({NAME: 'moe', AGE: 50, USERID: 'moe1'}, 'userid');<br />=> {NAME: 'moe', AGE: 50}</pre></p>

<p id='defaults'><b class='header'>defaults</b> <code>_.defaults(object, *defaults) : any</code><br />Fill in missing properties in object with default values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.<br /><pre>iceCream = {flavor : "chocolate"};<br />_.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});<br />=> {flavor : "chocolate", sprinkles : "lots"}</pre></p>

<p id='clone'><b class='header'>clone</b> <code>_.clone(object) : any</code><br />Create a shallow-copied clone of the object. Any nested structs or objects will be copied by reference, not duplicated.<br /><pre>_.clone({name : 'moe'});<br />=> {name : 'moe'}</pre></p>

<p id='has'><b class='header'>has</b> <code>_.has(object, key) : boolean</code><br />Does the object contain the given key? Delegates to _.include() for arrays or native structKeyExists() for objects.<br /><pre>_.has({a: 1, b: 2, c: 3}, "b");<br />=> true</pre></p>

<p id='isEqual'><b class='header'>isEqual</b> <code>_.isEqual(object, other)</code><br />Performs a deep comparison between the two objects, to determine if they should be considered equal.<br /><pre>moe = {name : 'moe', luckyNumbers : [13, 27, 34]};<br />clone = {name : 'moe', luckyNumbers : [13, 27, 34]};<br />_.isEqual(moe, clone);<br />=> true</pre></p>

<p id='isEmpty'><b class='header'>isEmpty</b> <code>_.isEmpty(object) : boolean</code><br />Returns true if object contains no values. Delegates to ArrayLen for arrays, structIsEmpty() otherwise.<br /><pre>_.isEmpty([1, 2, 3]);<br />=> false<br />_.isEmpty({});<br />=> true</pre></p>

<p id='isArray'><b class='header'>isArray</b> <code>_.isArray(object) : boolean</code><br />Returns true if object is an Array. Delegates to native isArray();<br /><pre>_.isArray({one: 1});<br />=> false<br />_.isArray([1,2,3]);<br />=> true</pre></p>

<p id='isObject'><b class='header'>isObject</b> <code>_.isObject(object) : boolean</code><br />Returns true if value is an Object. Delegates to native isObject()<br /><pre>_.isObject(new Component());<br />=> true <br />_.isObject({});<br />=> false</pre></p>

<p id='isFunction'><b class='header'>isFunction</b> <code>_.isFunction(object) : boolean</code><br />Returns true if object is a Function.	Delegates to native isClosure() || isCustomFunction()<br /><pre>_.isFunction(function(){return 1;});<br />=> true</pre></p>

<p id='isString'><b class='header'>isString</b> <code>_.isString(object) : boolean</code><br />Returns true if object is a String. Uses Java String type comparison.<br /><pre>_.isString("moe");<br />=> true<br />_.isString(1);<br />=> true//Coldfusion converts numbers to strings</pre></p>

<p id='isNumber'><b class='header'>isNumber</b> <code>_.isNumber(object) : boolean</code><br />Returns true if object is of a Java numeric type.<br /><pre>_.isNumber(1);<br />=> false//Coldfusion converts numbers to strings<br />_.isNumber(JavaCast("int", 1));<br />=> true</pre></p>

<p id='isBoolean'><b class='header'>isBoolean</b> <code>_.isBoolean(object) : boolean</code><br />Returns true if object is a boolean. Delegates to native isBoolean()<br /><pre>_.isBoolean(false);<br />=> true</pre></p>

<p id='isDate'><b class='header'>isDate</b> <code>_.isDate(object) : boolean</code><br />Returns true if object is a date. Delegates to native isDate()<br /><pre>_.isDate(now());<br />=> true</pre></p>
		<h2 id="Utilities">Utility Functions</h2>
		

<p id='times'><b class='header'>times</b> <code>_.times(n, iterator) : void</code><br />Invokes the given iterator function n times.<br /><pre>_.times(3, function(){ genie.grantWish(); });</pre></p>

<p id='random'><b class='header'>random</b> <code>_.random(min, max) : numeric</code><br />Returns a random integer between min and max, inclusive. If you only pass one argument, it will return a number between 0 and that number. Delegates to RandRange().<br /><pre>_.random(0, 100);<br />=> 42</pre></p>

<p id='mixin'><b class='header'>mixin</b> <code>_.mixin(object) : void</code><br />Allows you to extend Underscore with your own utility functions. Pass a struct of {name: function} definitions to have your functions added to the Underscore object, <s>as well as the OOP wrapper.</s><br /><pre>_.mixin({ <br />upper: function(string) { return uCase(string); }<br />});<br />_.upper("fabio");<br />=> "Fabio"</pre></p>

<p id='uniqueId'><b class='header'>uniqueId</b> <code>_.uniqueId([prefix]) : string</code><br />Generates an identifier that is unique for this instance of Underscore<br /><pre>_.uniqueId('c');<br /> => 'c1</pre></p>

<p id='escape'><b class='header'>escape</b> <code>_.escape(input) : string</code><br />Escapes a string for insertion into HTML, replacing &, <, >, and " characters.<br /><pre>_.escape('Curly, Larry & Moe');<br /> => "Curly, Larry &amp; Moe</pre></p>

<p id='result'><b class='header'>result</b> <code>_.result(object, property) : any</code><br />If the value of the named property is a function then invoke it; otherwise, return it.<br /><pre>object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};<br />_.result(object, 'cheese');<br />=> "crumpets"<br />_.result(object, 'stuff');<br />=> "nonsense"</pre></p>
		<p id="changelog">
			<h2>Change Log</h2>
			<p>
		        <b class="header">2.3</b> -- <small><i>December 12th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Updated slice to delegate to native arraySlice()</li>
	        	<li>Fixed mxunit testing expected/actual ordering</li>
	        	<li>Added handling for empty list values to toArray()</li>
	        	<li>Added value(), push(), pop(), shift(), unshift(), and join()</li>
	        	<li>Added fromIndex to lastIndexOf() and indexOf()</li>
	        	<li>Added countBy(), pairs(), invert(), random(), where(), omit(), and objects()</li>
	        	<li>Added Foundry support</li>
	        </ul>
			<p>
		        <b class="header">2.2</b> -- <small><i>August 10th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added splice(), uniqueId(), takeWhile(), and escape()</li>
	        	<li>Changed arrayConcat and arrayReverse to concat and reverse</li>
	        	<li>Implemented native arraySort for sortBy()</li>
	        	<li>Fixed iterator "key" parameter for Collection functions</li>
	        	<li>Fixed bind() argument mixup</li>
	        </ul>
			<p>
		        <b class="header">2.1</b> -- <small><i>July 9th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Fixed indexOf() index not found inconsistency</li>
	        	<li>Fixed iterator function indices for filter() and reject()</li>
	        	<li>Fixed Object clone and nested array clone</li>
	        </ul>
			<p>
		        <b class="header">2.0</b> -- <small><i>July 4th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added Railo 4 Support!</li>
	        	<li>Breaking changes: "this" now needs to be listed in the parameters of any iterator that references a passed in context.</li>
	        	<li>Cleaned up some writeDumps()</li>
	        	<li>Replaced isDefined() calls</li>
	        </ul>
			<p>
		        <b class="header">1.0</b> -- <small><i>June 30, 2012</i></small><br>
	        </p>
	        <ul>
	        	<li>
	        		First release! In under 30 days, woot!
		        </li>
	        </ul>
		</p>		
	</div>
	<a href="http://github.com/russplaysguitar/underscorecf"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
</body>
</html>