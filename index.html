<!DOCTYPE html>
<!-- saved from url=(0063) -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Underscore.cfc</title>
	
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<meta name="viewport" content="width=device-width">
	<link rel="stylesheet" type="text/css" href="index_files/style.css">
</head>
<body>
	<div id="sidebar" class="interface">
		<a class="toc_title" href="#">
		    Underscore.cfc <span class="version">(2.1)</span>
	    </a>
	    <a class="toc_title" href="#">
	    	Introduction
	    </a>
    	
    		
		    <a class="toc_title" href="#Collections">
			    Collections
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#each">each</a></li><li>- <a href="#map">map</a></li><li>- <a href="#reduce">reduce</a></li><li>- <a href="#reduceRight">reduceRight</a></li><li>- <a href="#find">find</a></li><li>- <a href="#filter">filter</a></li><li>- <a href="#reject">reject</a></li><li>- <a href="#all">all</a></li><li>- <a href="#any">any</a></li><li>- <a href="#include">include</a></li><li>- <a href="#invoke">invoke</a></li><li>- <a href="#pluck">pluck</a></li><li>- <a href="#max">max</a></li><li>- <a href="#min">min</a></li><li>- <a href="#sortBy">sortBy</a></li><li>- <a href="#groupBy">groupBy</a></li><li>- <a href="#sortedIndex">sortedIndex</a></li><li>- <a href="#shuffle">shuffle</a></li><li>- <a href="#toArray">toArray</a></li><li>- <a href="#size">size</a></li>			    	
		    </ul>
    	
    		
		    <a class="toc_title" href="#Arrays">
			    Arrays
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#first">first</a></li><li>- <a href="#initial">initial</a></li><li>- <a href="#last">last</a></li><li>- <a href="#rest">rest</a></li><li>- <a href="#compact">compact</a></li><li>- <a href="#flatten">flatten</a></li><li>- <a href="#without">without</a></li><li>- <a href="#union">union</a></li><li>- <a href="#intersection">intersection</a></li><li>- <a href="#difference">difference</a></li><li>- <a href="#uniq">uniq</a></li><li>- <a href="#zip">zip</a></li><li>- <a href="#indexOf">indexOf</a></li><li>- <a href="#lastIndexOf">lastIndexOf</a></li><li>- <a href="#range">range</a></li><li>- <a href="#arrayConcat">arrayConcat</a></li><li>- <a href="#arrayReverse">arrayReverse</a></li>			    	
		    </ul>
    	
    		
		    <a class="toc_title" href="#Functions">
			    Functions
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#bind">bind</a></li><li>- <a href="#bindAll">bindAll</a></li><li>- <a href="#memoize">memoize</a></li><li>- <a href="#delay">delay</a></li><li>- <a href="#once">once</a></li><li>- <a href="#after">after</a></li><li>- <a href="#wrap">wrap</a></li><li>- <a href="#compose">compose</a></li>			    	
		    </ul>
    	
    		
		    <a class="toc_title" href="#Objects">
			    Objects
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#keys">keys</a></li><li>- <a href="#values">values</a></li><li>- <a href="#functions">functions</a></li><li>- <a href="#extend">extend</a></li><li>- <a href="#pick">pick</a></li><li>- <a href="#defaults">defaults</a></li><li>- <a href="#clone">clone</a></li><li>- <a href="#has">has</a></li><li>- <a href="#isEqual">isEqual</a></li><li>- <a href="#isEmpty">isEmpty</a></li><li>- <a href="#isArray">isArray</a></li><li>- <a href="#isObject">isObject</a></li><li>- <a href="#isFunction">isFunction</a></li><li>- <a href="#isString">isString</a></li><li>- <a href="#isNumber">isNumber</a></li><li>- <a href="#isBoolean">isBoolean</a></li><li>- <a href="#isDate">isDate</a></li>			    	
		    </ul>
    	
    		
		    <a class="toc_title" href="#Utilities">
			    Utilities
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#times">times</a></li><li>- <a href="#mixin">mixin</a></li><li>- <a href="#result">result</a></li>			    	
		    </ul>
    	
	    <a class="toc_title" href="#changelog">
	    	Change Log
	    </a>    	
	</div>
	<div class="container">
		<h1>Underscore.cfc</h1>
		<p id="Introduction">
			Underscore.cfc is a port of <a href="http://underscorejs.org/">Underscore.js</a> for Coldfusion. It is a utility-belt library that provides a lot of the functional programming support that you would expect in Prototype.js (or Ruby). <br><br>Underscore.cfc provides dozens of functions that support both the usual functional suspects: map, select, invoke - as well as more specialized helpers: function binding, sorting, deep equality testing, and so on. It delegates to built-in functions where applicable.<br><br>Underscore.cfc is compatible with Adobe Coldfusion 10 and Railo 4.<br><br>The project is <a href="http://github.com/russplaysguitar/underscorecf">hosted on GitHub</a>. Contributions are welcome.<br>
		</p>		
		<h2>Download</h2>
		<div><a href="https://github.com/downloads/russplaysguitar/UnderscoreCF/Underscore.cfc.2.1.zip">Version 2.1</a> - <i>37kb, Includes unit tests and doc generator</i></div>
		<h2 id="Collections">Collection Functions (Arrays, Structs, Queries, or Objects)</h2>
		<p id="each"><b class="header">each</b> <code>_.each(collection, iterator, [context]) : void</code><br>Iterates over a collection of elements, yielding each in turn to an iterator function. The iterator is bound to the context object (component or struct), if one is passed. Each invocation of iterator is called with three arguments: (element, index, collection, this). If collection is an object/struct, iterator's arguments will be (value, key, collection, this).<br></p><pre>_.each([1, 2, 3], function(num){ writeDump(num); }); <br>=&gt; dumps each number in turn... <br>_.each({one : 1, two : 2, three : 3}, function(num, key){ writeDump(num); });<br>=&gt; dumps each number in turn...</pre><p></p><p id="map"><b class="header">map</b> <code>_.map(collection, iterator, [context]) : array</code><br>Produces a new array of values by mapping each value in collection through a transformation function (iterator). If collection is an object/struct, iterator's arguments will be (value, key, collection, this).<br></p><pre>_.map([1, 2, 3], function(num){ return num * 3; }); <br>=&gt; [3, 6, 9] <br>_.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3; });<br>=&gt; [3, 6, 9]</pre><p></p><p id="reduce"><b class="header">reduce</b> <code>_.reduce(collection, iterator, memo, [context]) : any</code><br>Also known as inject and foldl, reduce boils down a collection of values into a single value. Memo is the initial state of the reduction, and each successive step of it should be returned by iterator.<br></p><pre>sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);<br>=&gt; 6</pre><p></p><p id="reduceRight"><b class="header">reduceRight</b> <code>_.reduceRight(collection, [iterator], memo, [context])</code><br>The right-associative version of reduce.<br></p><pre>list = [[0, 1], [2, 3], [4, 5]];<br>flat = _.reduceRight(list, function(a, b) { return _.arrayConcat(a, b); }, []);<br>=&gt; [4, 5, 2, 3, 0, 1]</pre><p></p><p id="find"><b class="header">find</b> <code>_.find(collection, iterator, [context]) : any</code><br>Looks through each value in the collection, returning the first one that passes a truth test (iterator). The function returns as soon as it finds an acceptable element, and doesn't traverse the entire collection.<br></p><pre>even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; 2</pre><p></p><p id="filter"><b class="header">filter</b> <code>_.filter(collection, iterator, [context]) : array</code><br>Looks through each value in the collection, returning an array of all the values that pass a truth test (iterator).<br></p><pre>evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [2, 4, 6]</pre><p></p><p id="reject"><b class="header">reject</b> <code>_.reject(collection, iterator, [context]) : array</code><br>Returns the values in collection without the elements that the truth test (iterator) passes. The opposite of filter.<br></p><pre>odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [1, 3, 5]</pre><p></p><p id="all"><b class="header">all</b> <code>_.all(collection, iterator, [context]) : boolean</code><br>Returns true if all of the values in the collection pass the iterator truth test.<br></p><pre>_.all([true, 1, 'no'], _.identity);<br>=&gt; false</pre><p></p><p id="any"><b class="header">any</b> <code>_.any(collection, [iterator], [context]) : boolean</code><br>Returns true if any of the values in the collection pass the iterator truth test. Short-circuits and stops traversing the collection if a true element is found.<br></p><pre>_.any([0, 'yes', false]);<br>=&gt; true</pre><p></p><p id="include"><b class="header">include</b> <code>_.include(collection, value) : boolean</code><br>Returns true if the value is present in the collection.<br></p><pre>_.include([1, 2, 3], 3);<br>=&gt; true</pre><p></p><p id="invoke"><b class="header">invoke</b> <code>_.invoke(collection, methodName, [arguments]) : array</code><br>Calls the method named by methodName on each value in the collection. The arguments struct passed to invoke will be forwarded on to the method invocation.<br></p><pre>_.invoke([{fun: function(){ return 1; }}], 'fun');<br>=&gt; [1]</pre><p></p><p id="pluck"><b class="header">pluck</b> <code>_.pluck(collection, propertyName) : array</code><br>A convenient version of what is perhaps the most common use-case for map: extracting a collection of property values.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.pluck(stooges, 'name');<br>=&gt; ["moe", "larry", "curly"]</pre><p></p><p id="max"><b class="header">max</b> <code>_.max(collection, [iterator], [context]) : any</code><br>Returns the maximum value in collection. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.max(stooges, function(stooge){ return stooge.age; });<br>=&gt; {name : 'curly', age : 60};</pre><p></p><p id="min"><b class="header">min</b> <code>_.min(collection, [iterator], [context]) : any</code><br>Returns the minimum value in collection. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br></p><pre>numbers = [10, 5, 100, 2, 1000];<br>_.min(numbers);<br>=&gt; 2</pre><p></p><p id="sortBy"><b class="header">sortBy</b> <code>_.sortBy(collection, [iterator], [context]) : array</code><br>Returns a sorted copy of collection, ranked in ascending order by the results of running each value through iterator. Iterator may also be the string name of the object key to sort by. Uses a Merge Sort algorithm.<br></p><pre>_.sortBy([6, 2, 4, 3, 5, 1], function(num){ return num; });<br>=&gt; [1, 2, 3, 4, 5, 6]</pre><p></p><p id="groupBy"><b class="header">groupBy</b> <code>_.groupBy(collection, iterator) : struct</code><br>Splits a collection into sets, grouped by the result of running each value through iterator. If iterator is a string instead of a function, groups by the property named by iterator on each of the values.<br></p><pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return fix(num); });<br>=&gt; {1: [1.3], 2: [2.1, 2.4]}<br><br>_.groupBy(['one', 'two', 'three'], function(num) { return len(num); });<br>=&gt; {3: ["one", "two"], 5: ["three"]}</pre><p></p><p id="sortedIndex"><b class="header">sortedIndex</b> <code>_.sortedIndex(collection, value, [iterator]) : numeric</code><br>Uses a binary search to determine the index at which the value should be inserted into the collection in order to maintain the collection's sorted order. If an iterator is passed, it will be used to compute the sort ranking of each value.<br></p><pre>_.sortedIndex([10, 20, 30, 40, 50], 35);<br>=&gt; 4</pre><p></p><p id="shuffle"><b class="header">shuffle</b> <code>_.shuffle(array) : array</code><br>Returns a shuffled copy of the array, using a version of the Fisher-Yates shuffle.<br></p><pre>_.shuffle([1, 2, 3, 4, 5, 6]);<br>=&gt; [4, 1, 6, 3, 5, 2]</pre><p></p><p id="toArray"><b class="header">toArray</b> <code>_.toArray(collection) : array</code><br>Converts the collection (object, struct, query, or cf-list), into an array. Useful for transmuting the arguments object.<br></p><pre>_.toArray({a:10,b:20});<br>=&gt; [10, 20]</pre><p></p><p id="size"><b class="header">size</b> <code>_.size(collection) : numeric</code><br>Return the number of values in the collection.<br></p><pre>_.size({one : 1, two : 2, three : 3});<br>=&gt; 3</pre><p></p>
		<h2 id="Arrays">Array Functions</h2>
		<p id="first"><b class="header">first</b> <code>_.first(array, [n]) : any</code><br>Returns the first element of an array. Passing n will return the first n elements of the array.<br></p><pre>_.first([5, 4, 3, 2, 1]);<br>=&gt; 5</pre><p></p><p id="initial"><b class="header">initial</b> <code>_.initial(array, [n]) : array</code><br>Returns everything but the last entry of the array. Especially useful on the arguments object. Pass n to exclude the last n elements from the result. Note: CF arrays start at an index of 1<br></p><pre>_.initial([5, 4, 3, 2, 1]);<br>=&gt; [5, 4, 3, 2]</pre><p></p><p id="last"><b class="header">last</b> <code>_.last(array, [n]) : any</code><br>Returns the last element of an array. Passing n will return the last n elements of the array.<br></p><pre>_.last([5, 4, 3, 2, 1]);<br>=&gt; 1</pre><p></p><p id="rest"><b class="header">rest</b> <code>_.rest(array, [index]) : array</code><br>Returns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.<br></p><pre>_.rest([5, 4, 3, 2, 1]);<br>=&gt; [4, 3, 2, 1]</pre><p></p><p id="compact"><b class="header">compact</b> <code>_.compact(array) : array</code><br>Returns a copy of the array with all falsy values removed. In Coldfusion, false, 0, and "" are all falsy.<br></p><pre>_.compact([0, 1, false, 2, '', 3]);<br>=&gt; [1, 2, 3]</pre><p></p><p id="flatten"><b class="header">flatten</b> <code>_.flatten(array, [shallow]) : array</code><br>Flattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.<br></p><pre>_.flatten([1, [2], [3, [[4]]]]);<br>=&gt; [1, 2, 3, 4];<br><br>_.flatten([1, [2], [3, [[4]]]], true);<br>=&gt; [1, 2, 3, [[4]]];</pre><p></p><p id="without"><b class="header">without</b> <code>_.without(array, [values]) : array</code><br>Returns a copy of the array with all instances of the values removed.<br></p><pre>_.without([1, 2, 1, 0, 3, 1, 4], [0, 1]);<br>=&gt; [2, 3, 4]</pre><p></p><p id="union"><b class="header">union</b> <code>_.union(*arrays) : array</code><br>Computes the union of the passed-in arrays: the collection of unique items, in order, that are present in one or more of the arrays.<br></p><pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2, 3, 101, 10]</pre><p></p><p id="intersection"><b class="header">intersection</b> <code>_.intersection(*arrays) : array</code><br>Computes the collection of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.<br></p><pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2]</pre><p></p><p id="difference"><b class="header">difference</b> <code>_.difference(array, others) : array</code><br>Similar to without, but returns the values from array that are not present in the other arrays.<br></p><pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);<br>=&gt; [1, 3, 4]</pre><p></p><p id="uniq"><b class="header">uniq</b> <code>_.uniq(array, [isSorted], [iterator]) : array</code><br>Produces a duplicate-free version of the array. If you know in advance that the array is sorted, passing true for isSorted will run a much faster algorithm. If you want to compute unique items based on a transformation, pass an iterator function.<br></p><pre>_.uniq([1, 2, 1, 3, 1, 4]);<br>=&gt; [1, 2, 3, 4]</pre><p></p><p id="zip"><b class="header">zip</b> <code>_.zip(*arrays) : array</code><br>Merges together the values of each of the arrays with the values at the corresponding position. Useful when you have separate data sources that are coordinated through matching array indexes. If you're working with a matrix of nested arrays, zip.apply can transpose the matrix in a similar fashion.<br></p><pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);<br>=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]</pre><p></p><p id="indexOf"><b class="header">indexOf</b> <code>_.indexOf(array, value, [isSorted]) : numeric</code><br>Returns the index at which value can be found in the array, or 0 if value is not present in the array. Uses the native ArrayFind() function. If you're working with a large array, and you know that the array is already sorted, pass true for isSorted to use a faster binary search.<br></p><pre>_.indexOf([1, 2, 3], 2);<br>=&gt; 2</pre><p></p><p id="lastIndexOf"><b class="header">lastIndexOf</b> <code>_.lastIndexOf(array, value) : numeric</code><br>Returns the index of the last occurrence of value in the array, or -1 if value is not present.<br></p><pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);<br>=&gt; 5</pre><p></p><p id="range"><b class="header">range</b> <code>_.range([start], stop, [step]) : array</code><br>A function to create flexibly-numbered arrays of integers, handy for each and map loops. start, if omitted, defaults to 0; step defaults to 1. Returns an array of integers from start to stop, incremented (or decremented) by step, exclusive.<br></p><pre>_.range(10);<br>=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>_.range(1, 11);<br>=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>_.range(0, 30, 5);<br>=&gt; [0, 5, 10, 15, 20, 25]<br>_.range(0, -10, -1);<br>=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br>_.range(0);<br>=&gt; []</pre><p></p><p id="arrayConcat"><b class="header">arrayConcat</b> <code>_.arrayConcat(array1, array2) : array</code><br>Concatenates two arrays together an returns the result. Delegates to ArrayAppend().<br></p><pre>_.arrayConcat([1, 2, 3],[4, 5, 6]);<br>=&gt; [1, 2, 3, 4, 5, 6];</pre><p></p><p id="arrayReverse"><b class="header">arrayReverse</b> <code>_.arrayReverse(array) : array</code><br>Returns a copy of the array in reverse order.<br></p><pre>_.arrayReverse([1, 2, 3]);<br>=&gt; [3, 2, 1];</pre><p></p>
		<h2 id="Functions">Function (uh, ahem) Functions</h2>
		<p id="bind"><b class="header">bind</b> <code>_.bind(function, object, [*arguments]) : any</code><br>Bind a function to a structure, meaning that whenever the function is called, the value of "this" will be the structure. Optionally, bind arguments to the function to pre-fill them, also known as partial application.<br></p><pre>func = function(args, this){ return args.greeting &amp; ': ' &amp; this.name; };<br>func = _.bind(func, {name : 'moe'}, {greeting: 'hi'});<br>func();<br>=&gt; 'hi: moe'</pre><p></p><p id="bindAll"><b class="header">bindAll</b> <code>_.bindAll(object, [*methodNames]) : any</code><br>Bind all of an object's methods to that object. Useful for ensuring that all callbacks defined on an object belong to it.<br></p><pre>buttonView = {label: 'button', onClick : function(this){ return 'clicked: ' &amp; this.label; }};<br>_.bindAll(buttonView);<br>buttonView.onClick();<br>=&gt; 'clicked: button'</pre><p></p><p id="memoize"><b class="header">memoize</b> <code>_.memoize(function, [hashFunction]) : any</code><br>Memoizes a given function by caching the computed result. Useful for speeding up slow-running computations. If passed an optional hashFunction, it will be used to compute the hash key for storing the result, based on the arguments to the original function. The default hashFunction just uses the first argument to the memoized function as the key.<br></p><pre>fibonacci = _.memoize(function(n) {  return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); });</pre><p></p><p id="delay"><b class="header">delay</b> <code>_.delay(function, wait, arguments) : any</code><br>Delays a function for the given number of milliseconds, and then calls it with the arguments supplied in the args struct.<br></p><pre>_.delay(function (msg) {return msg;}, 1000, {msg = "hi"});<br>=&gt; "hi" // appears after one second</pre><p></p><p id="once"><b class="header">once</b> <code>_.once(function) : any</code><br>Returns a function that will be executed at most one time, no matter how often you call it. Useful for lazy initialization.<br></p><pre>i = 0;<br>once = _.once(function () { i = i+1; return i; });<br>once();<br>=&gt; 1<br>once();<br>=&gt; 1</pre><p></p><p id="after"><b class="header">after</b> <code>_.after(count, function) : any</code><br>Returns a function that will only be executed after being called N times.<br></p><pre>func = function () { writeOutput("hi"); };<br>callFuncAfterTwo = _.after(2, func);<br>callFuncAfterTwo();<br>=&gt; // nothing<br>callFuncAfterTwo();<br>=&gt; 'hi'</pre><p></p><p id="wrap"><b class="header">wrap</b> <code>_.wrap(function, wrapper) : any</code><br>Returns the first function passed as an argument to the second, allowing you to adjust arguments, run code before and after, and conditionally execute the original function.<br></p><pre>hello = function(name) { return "hello: " &amp; name; };<br>hello = _.wrap(hello, function(func) {<br>return "before, " &amp; func("moe") &amp; ", after";<br>});<br>hello();<br>=&gt; 'before, hello: moe, after'</pre><p></p><p id="compose"><b class="header">compose</b> <code>_.compose(*functions) : any</code><br>Returns a function that is the composition of a list of functions, each function consumes the return value of the function that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).<br></p><pre>greet    = function(name){ return "hi: " &amp; name; };<br>exclaim  = function(statement){ return statement &amp; "!"; };<br>welcome = _.compose(exclaim, greet);<br>welcome('moe');<br>=&gt; 'hi: moe!';</pre><p></p>
		<h2 id="Objects">Object/Struct Functions</h2>
		<p id="keys"><b class="header">keys</b> <code>_.keys(object) : array</code><br>Retrieve all the names of the object's properties.<br></p><pre>_.keys({one : 1, two : 2, three : 3});<br>=&gt; ["one", "two", "three"]</pre><p></p><p id="values"><b class="header">values</b> <code>_.values(object) : array</code><br>Returns true if any of the values in the object pass the iterator truth test. Short-circuits and stops traversing the object if a true element is found.<br></p><pre>_.values({one : 1, two : 2, three : 3});<br>=&gt; [1, 2, 3]</pre><p></p><p id="functions"><b class="header">functions</b> <code>_.functions(object) : array</code><br>Returns a sorted array of the names of every method in an object -- that is to say, the name of every function property of the object.<br></p><pre>_.functions(_);<br>=&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...</pre><p></p><p id="extend"><b class="header">extend</b> <code>_.extend(destination, *sources) : any</code><br>Copy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.<br></p><pre>_.extend({name : 'moe'}, {age : 50});<br>=&gt; {name : 'moe', age : 50}</pre><p></p><p id="pick"><b class="header">pick</b> <code>_.pick(object, *keys) : struct</code><br>Return a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys).<br></p><pre>_.pick({name : 'moe', age: 50, userid : 'moe1'}, 'name', 'age');<br>=&gt; {name : 'moe', age : 50}</pre><p></p><p id="defaults"><b class="header">defaults</b> <code>_.defaults(object, *defaults) : any</code><br>Fill in missing properties in object with default values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.<br></p><pre>iceCream = {flavor : "chocolate"};<br>_.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});<br>=&gt; {flavor : "chocolate", sprinkles : "lots"}</pre><p></p><p id="clone"><b class="header">clone</b> <code>_.clone(object) : any</code><br>Create a shallow-copied clone of the object. Any nested structs or objects will be copied by reference, not duplicated.<br></p><pre>_.clone({name : 'moe'});<br>=&gt; {name : 'moe'}</pre><p></p><p id="has"><b class="header">has</b> <code>_.has(object, key) : boolean</code><br>Does the object contain the given key? Delegates to _.include() for arrays or native structKeyExists() for objects.<br></p><pre>_.has({a: 1, b: 2, c: 3}, "b");<br>=&gt; true</pre><p></p><p id="isEqual"><b class="header">isEqual</b> <code>_.isEqual(object, other)</code><br>Performs a deep comparison between the two objects, to determine if they should be considered equal.<br></p><pre>moe = {name : 'moe', luckyNumbers : [13, 27, 34]};<br>clone = {name : 'moe', luckyNumbers : [13, 27, 34]};<br>_.isEqual(moe, clone);<br>=&gt; true</pre><p></p><p id="isEmpty"><b class="header">isEmpty</b> <code>_.isEmpty(object) : boolean</code><br>Returns true if object contains no values. Delegates to ArrayLen for arrays, structIsEmpty() otherwise.<br></p><pre>_.isEmpty([1, 2, 3]);<br>=&gt; false<br>_.isEmpty({});<br>=&gt; true</pre><p></p><p id="isArray"><b class="header">isArray</b> <code>_.isArray(object) : boolean</code><br>Returns true if object is an Array. Delegates to native isArray();<br></p><pre>_.isArray({one: 1});<br>=&gt; false<br>_.isArray([1,2,3]);<br>=&gt; true</pre><p></p><p id="isObject"><b class="header">isObject</b> <code>_.isObject(object) : boolean</code><br>Returns true if value is an Object. Delegates to native isObject()<br></p><pre>_.isObject(new Component());<br>=&gt; true <br>_.isObject({});<br>=&gt; false</pre><p></p><p id="isFunction"><b class="header">isFunction</b> <code>_.isFunction(object) : boolean</code><br>Returns true if object is a Function.	Delegates to native isClosure() || isCustomFunction()<br></p><pre>_.isFunction(function(){return 1;});<br>=&gt; true</pre><p></p><p id="isString"><b class="header">isString</b> <code>_.isString(object) : boolean</code><br>Returns true if object is a String. Uses Java String type comparison.<br></p><pre>_.isString("moe");<br>=&gt; true<br>_.isString(1);<br>=&gt; true//Coldfusion converts numbers to strings</pre><p></p><p id="isNumber"><b class="header">isNumber</b> <code>_.isNumber(object) : boolean</code><br>Returns true if object is of a Java numeric type.<br></p><pre>_.isNumber(1);<br>=&gt; false//Coldfusion converts numbers to strings<br>_.isNumber(JavaCast("int", 1));<br>=&gt; true</pre><p></p><p id="isBoolean"><b class="header">isBoolean</b> <code>_.isBoolean(object) : boolean</code><br>Returns true if object is a boolean. Delegates to native isBoolean()<br></p><pre>_.isBoolean(false);<br>=&gt; true</pre><p></p><p id="isDate"><b class="header">isDate</b> <code>_.isDate(object) : boolean</code><br>Returns true if object is a date. Delegates to native isDate()<br></p><pre>_.isDate(now());<br>=&gt; true</pre><p></p>
		<h2 id="Utilities">Utility Functions</h2>
		<p id="times"><b class="header">times</b> <code>_.times(n, iterator) : void</code><br>Invokes the given iterator function n times.<br></p><pre>_.times(3, function(){ genie.grantWish(); });</pre><p></p><p id="mixin"><b class="header">mixin</b> <code>_.mixin(object) : void</code><br>Allows you to extend Underscore with your own utility functions. Pass a struct of {name: function} definitions to have your functions added to the Underscore object, <s>as well as the OOP wrapper.</s><br></p><pre>_.mixin({ <br>upper: function(string) { return uCase(string); }<br>});<br>_.upper("fabio");<br>=&gt; "Fabio"'</pre><p></p><p id="result"><b class="header">result</b> <code>_.result(object, property) : any</code><br>If the value of the named property is a function then invoke it; otherwise, return it.<br></p><pre>object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};<br>_.result(object, 'cheese');<br>=&gt; "crumpets"<br>_.result(object, 'stuff');<br>=&gt; "nonsense"</pre><p></p>
		<p id="changelog">
			</p><h2>Change Log</h2>
			<p>
		        <b class="header">2.1</b> -- <small><i>July 9th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Fixed indexOf() index not found inconsistency</li>
	        	<li>Fixed iterator function indices for filter() and reject()</li>
	        	<li>Fixed Object clone and nested array clone</li>
	        </ul>
			<p>
		        <b class="header">2.0</b> -- <small><i>July 4th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added Railo 4 Support!</li>
	        	<li>Breaking changes: "this" now needs to be listed in the parameters of any iterator that references a passed in context.</li>
	        	<li>Cleaned up some writeDumps()</li>
	        	<li>Replaced isDefined() calls</li>
	        </ul>
			<p>
		        <b class="header">1.0</b> -- <small><i>June 30, 2012</i></small><br>
	        </p>
	        <ul>
	        	<li>
	        		First release! In under 30 days, woot!
		        </li>
	        </ul>
		<p></p>		
	</div>
	<a href="http://github.com/russplaysguitar/underscorecf"><img style="position: absolute; top: 0; right: 0; border: 0;" src="index_files/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

</body>
</html>